FRONTEND CODE:

frontend/login.htm

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Login | Automated Grading</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <!-- Custom CSS -->
  <link rel="stylesheet" href="login-styles.css">
</head>
<body>
  <div class="login-page">
    <div class="login-card">
      <div class="card-body">
        <!-- Heading Section -->
        <div class="heading-section">
          <i class="fas fa-user-circle auth-icon"></i>
          <h2>Welcome Back</h2>
          <p>Please login to your account</p>
        </div>

        <form method="post" action="/login">
          <!-- Email Field -->
          <div class="form-group">
            <div class="input-group">
              <span class="input-group-text">
                <i class="fas fa-envelope"></i>
              </span>
              <input
                type="email"
                class="form-control"
                id="email"
                name="email"
                placeholder="Email address"
                required
              />
            </div>
          </div>

          <!-- Password Field -->
          <div class="form-group">
            <div class="input-group">
              <span class="input-group-text">
                <i class="fas fa-lock"></i>
              </span>
              <input
                type="password"
                class="form-control"
                id="password"
                name="password"
                placeholder="Password"
                required
              />
            </div>
          </div>

          <!-- Remember + Forgot Password -->
          <div class="form-group row-between">
            <div class="checkbox">
              <input
                type="checkbox"
                id="remember"
                name="remember"
              />
              <label for="remember">Remember me</label>
            </div>
            <a href="/forgot-password" class="forgot-password">Forgot Password?</a>
          </div>

          <!-- Login Button -->
          <div class="form-group">
            <button type="submit" class="btn btn-primary">
              Login <i class="fas fa-arrow-right"></i>
            </button>
          </div>

          <!-- Sign Up Link -->
          <div class="bottom-text">
            <p>
              Don't have an account?
              <a href="/signup">Sign up</a>
            </p>
          </div>
        </form>
      </div>
    </div>
  </div>
</body>
</html>



frontend/dashboard.htm

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professor Dashboard</title>
    <link rel="stylesheet" href="professor-styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
</head>
<body>
    <!-- Header -->
    <header class="topbar">
        <div class="left">
            <button class="menu-btn">?</button>
            <img src="classroom-logo.png" alt=" " class="logo">
            <h2>AutoGrade</h2>
        </div>
        <div class="search-bar">
            <input type="text" placeholder="Search Courses">
        </div>
        <div class="right">
            <button class="add-btn">+</button>
            <button class="grid-btn">?</button>
            <a href="profile.htm">
                <img src="profile-pic.jpg" alt="Profile Picture" class="profile-pic">
            </a>
        </div>
    </header>

    <div class="dashboard-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <ul class="navigation">
                <li><a href="#" class = "active"><i class="fas fa-home"></i> Home</a></li>
                <li><a href="#"><i class="fas fa-graduation-cap"></i> Teaching</a></li>
                <li><a href="#"><i class="fas fa-user-graduate"></i> Enrolled</a></li>
                <li><a href="#"><i class="fas fa-archive"></i> Archived</a></li>
                <li><a href="#"><i class="fas fa-cog"></i> Settings</a></li>
                <li><a href="#" class="logout"><i class="fas fa-sign-out-alt"></i> Logout</a></li>
            </ul>
    
        </aside>
        
        <!-- Main Content -->
        <main class="content">
            <h1>My Courses</h1>
            <div class="course-grid">
                <a href="courses.htm" class="course-card">
                    <div class="course-header">CP301 DEP (2025 Jan-May)</div>
                    <p>Dr. Puneet Goyal</p>
                </a>

                <a href="courses.htm" class="course-card">
                    <div class="course-header">CS306 TOC 2024</div>
                    <p>Dr. Anil Shukla</p>
                </a>

                <a href="course3.html" class="course-card">
                    <div class="course-header">CS304 2025 Jan-May</div>
                    <p>Dr. Sudeeptha Mishra</p>
                </a>

                <a href="course4.html" class="course-card">
                    <div class="course-header">HS301 Jan June 2025</div>
                    <p>Dr. Ravi Kumar</p>
                </a>

                <a href="course5.html" class="course-card">
                    <div class="course-header">CS305 - Software Engineering</div>
                    <p>Dr. Balwinder Sodhi</p>
                </a>

                <a href="course6.html" class="course-card">
                    <div class="course-header">MA201 - 2023</div>
                    <p>Dr. Sairam Kaliraj</p>
                </a>
            </div>
        </main>
    </div>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const menuButton = document.querySelector(".menu-btn");
            const sidebar = document.querySelector(".sidebar");
    
            menuButton.addEventListener("click", function () {
                sidebar.classList.toggle("collapsed");
            });
        });
    
    </script>
</body>

</html>



frontend/courses.htm

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course - CP301</title>
    <link rel="stylesheet" href="professor-styles.css">
    <link rel="stylesheet" href="announcement-styles.css">
    <!-- <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
</head>
<body>
    <!-- Header -->
    <header class="topbar">
        <div class="left">
            <button class="menu-btn">?</button>
            <img src="classroom-logo.png" alt=" " class="logo">
            <h2>AutoGrade</h2>
        </div>
        <div class="search-bar">
            <input type="text" placeholder="Search Courses">
        </div>
        <div class="right">
            <button class="add-btn">+</button>
            <a href="profile.htm">
                <img src="profile-pic.jpg" alt="Profile Picture" class="profile-pic">
            </a>
        </div>
    </header>

    <div class="dashboard-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <ul class="navigation">
                <li><a href="#" class = "active"><i class="fas fa-home"></i> Home</a></li>
                <li><a href="#"><i class="fas fa-graduation-cap"></i> Teaching</a></li>
                <li><a href="#"><i class="fas fa-user-graduate"></i> Enrolled</a></li>
                <li><a href="#"><i class="fas fa-archive"></i> Archived</a></li>
                <li><a href="#"><i class="fas fa-cog"></i> Settings</a></li>
                <li><a href="#" class="logout"><i class="fas fa-sign-out-alt"></i> Logout</a></li>
            </ul>
    
        </aside>
        
    
        <main class="content">
            <!-- Tabs -->
            <nav class="tabs">
                <button class="tab-link active" onclick="openTab(event, 'announcements')">Announcements</button>
                <button class="tab-link" onclick="openTab(event, 'exams')">Exams</button>
                <button class="tab-link" onclick="openTab(event, 'people')">People</button>
            </nav>

            <!-- Tab Content -->
            <!-- ANNOUNCEMENTS TAB -->
            <div id="announcements" class="tab-content" style="display: block;">
                <div class="announcement-container">
                <!-- Announcement Input -->
                <div
                    id="announceInput"
                    class="announce-input"
                    contenteditable="true"
                    onfocus="expandAnnouncement()"
                    data-placeholder="Announce something to your class..."
                ></div>

                <!-- Toolbar (appears when user focuses or starts typing) -->
                <div class="toolbar" id="toolbar">
                    <div>
                    <button onclick="formatText('bold', this)"><b>B</b></button>
                    <button onclick="formatText('italic', this)"><i>I</i></button>
                    <button onclick="formatText('underline', this)"><u>U</u></button>
                    <button onclick="formatText('strikeThrough', this)"><s>S</s></button>
                    </div>
                    <div>
                    <button class="cancel-btn" onclick="cancelAnnouncement()">Cancel</button>
                    <button class="post-btn" onclick="postAnnouncement()">Post</button>
                    </div>
                </div>
                <!-- Posted Announcements -->
                <div id="announcementList" class="announcement-list"></div>
                </div>
            </div>




            <div id="exams" class="tab-content">
                <div class="exam-container">
                    <div class="exam-box">
                        <a href="exam.htm" class="exam-box-link">
                        
                            <div class="exam-header">
                                <div class="exam-title">
                                    <h2>End-Semester Exam</h2>
                                    <p>December 15, 2023</p>
                                </div>
                                <div class="exam-status">
                                    <img src="checkmark.svg" alt="Completed" width="24" height="24">
                                </div>
                            </div>
                            <div class="info-box">
                                <h3>Answer Scripts</h3>
                                <div class="stats-grid">
                                    <div class="stat-item"><span>Uploaded:</span><span>45</span></div>
                                    <div class="stat-item"><span>Checked:</span><span>42</span></div>
                                </div>
                            </div>
                            <div class="info-box">
                                <h3>Marks Overview</h3>
                                <div class="stats-grid">
                                    <div class="stat-item"><span>Total Marks:</span><span>30</span></div>
                                    <div class="stat-item"><span>Average Marks:</span><span>25</span></div>
                                </div>
                            </div>
                        </a>
                    </div>

                    <div class="exam-box">
                        <a href="exam.htm" class="exam-box-link">
                            <div class="exam-header">
                                <div class="exam-title">
                                    <h2>Mid-Semester Exam</h2>
                                    <p>December 18, 2023</p>
                                </div>
                                <div class="exam-status">
                                    <img src="checkmark.svg" alt="Completed" width="24" height="24">
                                </div>
                            </div>
                            <div class="info-box">
                                <h3>Answer Scripts</h3>
                                <div class="stats-grid">
                                    <div class="stat-item"><span>Uploaded:</span><span>50</span></div>
                                    <div class="stat-item"><span>Checked:</span><span>48</span></div>
                                </div>
                            </div>
                            <div class="info-box">
                                <h3>Marks Overview</h3>
                                <div class="stats-grid">
                                    <div class="stat-item"><span>Total Marks:</span><span>40</span></div>
                                    <div class="stat-item"><span>Average Marks:</span><span>35</span></div>
                                </div>
                            </div>
                        </a>
                    </div>
            
                    <div class="exam-box">
                        <a href="exam.htm" class="exam-box-link">
                            <div class="exam-header">
                                <div class="exam-title">
                                    <h2>Quiz 2</h2>
                                    <p>December 15, 2023</p>
                                </div>
                                <div class="exam-status">
                                    <img src="checkmark.svg" alt="Completed" width="24" height="24">
                                </div>
                            </div>
                            <div class="info-box">
                                <h3>Answer Scripts</h3>
                                <div class="stats-grid">
                                    <div class="stat-item"><span>Uploaded:</span><span>45</span></div>
                                    <div class="stat-item"><span>Checked:</span><span>42</span></div>
                                </div>
                            </div>
                            <div class="info-box">
                                <h3>Marks Overview</h3>
                                <div class="stats-grid">
                                    <div class="stat-item"><span>Total Marks:</span><span>30</span></div>
                                    <div class="stat-item"><span>Average Marks:</span><span>25</span></div>
                                </div>
                            </div>
                        </a>
                    </div>
            
                    <div class="exam-box">
                        <a href="exam.htm" class="exam-box-link">
                            <div class="exam-header">
                                <div class="exam-title">
                                    <h2>Quiz 1</h2>
                                    <p>December 15, 2023</p>
                                </div>
                                <div class="exam-status">
                                    <img src="checkmark.svg" alt="Completed" width="24" height="24">
                                </div>
                            </div>
                            <div class="info-box">
                                <h3>Answer Scripts</h3>
                                <div class="stats-grid">
                                    <div class="stat-item"><span>Uploaded:</span><span>45</span></div>
                                    <div class="stat-item"><span>Checked:</span><span>42</span></div>
                                </div>
                            </div>
                            <div class="info-box">
                                <h3>Marks Overview</h3>
                                <div class="stats-grid">
                                    <div class="stat-item"><span>Total Marks:</span><span>30</span></div>
                                    <div class="stat-item"><span>Average Marks:</span><span>25</span></div>
                                </div>
                            </div>
                        </a>
                    </div>
                </div>
            </div>
            
            



            <div id="people" class="tab-content">
                <h3>Teachers</h3>
                <ul class="people-list">
                    <li>????? Puneet Goyal</li>
                </ul>
                
                <h3>Students</h3>
                <ul class="people-list">
                    <li>????? Rahul Sharma</li>
                    <li>????? Ananya Singh</li>
                    <li>????? Rohan Mehta</li>
                </ul>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const menuButton = document.querySelector(".menu-btn");
            const sidebar = document.querySelector(".sidebar");

            menuButton.addEventListener("click", function () {
                sidebar.classList.toggle("collapsed");
            });
        });

        function openTab(event, tabName) {
            let tabs = document.getElementsByClassName("tab-content");
            for (let tab of tabs) {
                tab.style.display = "none";
            }
            document.getElementById(tabName).style.display = "block";

            let tabLinks = document.getElementsByClassName("tab-link");
            for (let tabLink of tabLinks) {
                tabLink.classList.remove("active");
            }
            event.currentTarget.classList.add("active");
        }

        document.getElementById("announcements").style.display = "block";
    </script>
    <script src="announcements.js"></script>

</body>
</html>







BACKEND CODE:


backend/database.py

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from .config import settings

SQLALCHEMY_DATABASE_URL = settings.DATABASE_URL

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
        
        
backend/main.py

from fastapi import FastAPI, Request, Depends, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.responses import RedirectResponse
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
import os
import logging

from classroom_app.database import engine, get_db, Base
from classroom_app.routers import auth, classes, enrollments, notifications, announcements
from classroom_app.utils.security import get_current_user_from_cookie
from classroom_app.config import settings
from classroom_app.models.tables import Classroom, Enrollment
from classroom_app.models.users import User

# Configure logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Create database tables
Base.metadata.create_all(bind=engine)  #This line reads the metadata defined by your ORM models (using the Base class) and creates all the corresponding tables in the database.

app = FastAPI(title=settings.PROJECT_NAME, version=settings.PROJECT_VERSION)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Setup static files
static_path = os.path.join(os.path.dirname(__file__), "static")
app.mount("/static", StaticFiles(directory=static_path), name="static")

templates = Jinja2Templates(directory=os.path.join(os.path.dirname(__file__), "templates"))

# Include routers
app.include_router(auth.router)
app.include_router(enrollments.router)
app.include_router(classes.router)
app.include_router(notifications.router)
app.include_router(announcements.router)

@app.get("/")
async def root(request: Request):
    """
    Root route that redirects to login if not authenticated,
    or dashboard if authenticated
    """
    try:
        return RedirectResponse(url="/login", status_code=303)
    except Exception as e:
        logger.error(f"Error in root route: {str(e)}", exc_info=True)
        return RedirectResponse(url="/login", status_code=303)

@app.get("/health")
async def health_check():
    return {"status": "ok", "version": settings.PROJECT_VERSION}

# Add middleware for request logging
@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    try:
        response = await call_next(request)
        return response
    except Exception as e:
        logger.error(f"Error in middleware: {str(e)}", exc_info=True)
        raise

# Run the application
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("classroom_app.main:app", host="0.0.0.0", port=8000, reload=True)
    
   
   
backend/config.py

import os
import secrets
from dotenv import load_dotenv

load_dotenv()

class Settings:
    PROJECT_NAME = "Institute Classroom Portal"
    PROJECT_VERSION = "1.0.0"
    
    # Environment
    ENV = os.getenv("ENV", "development")
    DEBUG = ENV == "development"
    
    # Security settings
    SECRET_KEY = os.getenv("SECRET_KEY", secrets.token_hex(32))
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", 60 * 24))  # 24 hours
    
    # Cookie settings
    COOKIE_SECURE = ENV != "development"  # Use secure cookies in production
    COOKIE_DOMAIN = os.getenv("COOKIE_DOMAIN", None)
    COOKIE_SAMESITE = "lax"
    
    # Database settings
    DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./classroom.db")
    DATABASE_POOL_SIZE = int(os.getenv("DATABASE_POOL_SIZE", 20))
    DATABASE_MAX_OVERFLOW = int(os.getenv("DATABASE_MAX_OVERFLOW", 10))
    DATABASE_POOL_TIMEOUT = int(os.getenv("DATABASE_POOL_TIMEOUT", 30))
    
    # Email settings (for future use)
    MAIL_USERNAME = os.getenv("MAIL_USERNAME", "")
    MAIL_PASSWORD = os.getenv("MAIL_PASSWORD", "")
    MAIL_FROM = os.getenv("MAIL_FROM", "noreply@institute.edu")
    MAIL_SERVER = os.getenv("MAIL_SERVER", "")

settings = Settings()



backend/models/__init__.py

from classroom_app.database import Base
from classroom_app.models.users import User, UserSettings, LoginHistory
from classroom_app.models.tables import (
    Classroom, Enrollment, Assignment, Submission, 
    Announcement, Exam, ExamResult,
    Material, Query,
    AssignmentStatus, EnrollmentStatus, Role
)
from classroom_app.models.notifications import Notification, NotificationType


backend/models/tables.py

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text, Boolean, Enum
from sqlalchemy.orm import relationship
from datetime import datetime, timezone
import shortuuid
import enum
from classroom_app.database import Base

class AssignmentStatus(str, enum.Enum):
    PENDING = "pending"
    SUBMITTED = "submitted"
    GRADED = "graded"
    LATE = "late"

class EnrollmentStatus(str, enum.Enum):
    PENDING = "pending"
    ACCEPTED = "accepted"
    REJECTED = "rejected"

class Role(str, enum.Enum):
    STUDENT = "student"
    TA = "ta"
    PROFESSOR = "professor"

class Classroom(Base):
    __tablename__ = "classrooms"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    subject = Column(String, nullable=False)
    description = Column(Text, nullable=True)
    class_code = Column(String, unique=True, index=True, default=lambda: shortuuid.ShortUUID().random(length=6).upper())
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    owner_id = Column(Integer, ForeignKey("users.id"))
    is_archived = Column(Boolean, default=False)

    # Relationships
    owner = relationship("User", back_populates="owned_classes")
    enrollments = relationship("Enrollment", back_populates="classroom", cascade="all, delete-orphan")
    assignments = relationship("Assignment", back_populates="classroom", cascade="all, delete-orphan")
    announcements = relationship("Announcement", back_populates="classroom", cascade="all, delete-orphan")
    exams = relationship("Exam", back_populates="classroom", cascade="all, delete-orphan")
    materials = relationship("Material", back_populates="classroom", cascade="all, delete-orphan")
    queries = relationship("Query", back_populates="classroom", cascade="all, delete-orphan")

class Enrollment(Base):
    __tablename__ = "enrollments"

    id = Column(Integer, primary_key=True, index=True)
    student_id = Column(Integer, ForeignKey("users.id"))
    classroom_id = Column(Integer, ForeignKey("classrooms.id"))
    status = Column(Enum(EnrollmentStatus), default=EnrollmentStatus.PENDING)
    role = Column(Enum(Role), default=Role.STUDENT)
    joined_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    last_accessed = Column(DateTime, nullable=True)

    # Relationships
    student = relationship("User", back_populates="enrollments")
    classroom = relationship("Classroom", back_populates="enrollments")

class Assignment(Base):
    __tablename__ = "assignments"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, nullable=False)
    description = Column(Text, nullable=True)
    due_date = Column(DateTime, nullable=True)
    points_possible = Column(Integer, default=100)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    classroom_id = Column(Integer, ForeignKey("classrooms.id"))
    author_id = Column(Integer, ForeignKey("users.id"))
    attachment_path = Column(String, nullable=True)

    # Relationships
    classroom = relationship("Classroom", back_populates="assignments")
    author = relationship("User")
    submissions = relationship("Submission", back_populates="assignment", cascade="all, delete-orphan")
    
    materials = relationship("Material", back_populates="assignment", cascade="all, delete-orphan")
    # Allow queries on an assignment
    queries = relationship("Query", back_populates="assignment", cascade="all, delete-orphan")
    

class Submission(Base):
    __tablename__ = "submissions"

    id = Column(Integer, primary_key=True, index=True)
    content = Column(Text, nullable=True)
    file_path = Column(String, nullable=True)
    submitted_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    grade = Column(Integer, nullable=True)
    feedback = Column(Text, nullable=True)
    status = Column(Enum(AssignmentStatus), default=AssignmentStatus.PENDING)
    assignment_id = Column(Integer, ForeignKey("assignments.id"))
    student_id = Column(Integer, ForeignKey("users.id"))
    graded_by = Column(Integer, ForeignKey("users.id"), nullable=True)
    graded_at = Column(DateTime, nullable=True)

    # Relationships
    assignment = relationship("Assignment", back_populates="submissions")
    student = relationship("User", foreign_keys=[student_id])
    grader = relationship("User", foreign_keys=[graded_by])

class Announcement(Base):
    __tablename__ = "announcements"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, nullable=False)
    content = Column(Text, nullable=False)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = Column(DateTime, onupdate=lambda: datetime.now(timezone.utc))
    classroom_id = Column(Integer, ForeignKey("classrooms.id"))
    author_id = Column(Integer, ForeignKey("users.id"))
    attachment_path = Column(String, nullable=True)

    classroom = relationship("Classroom", back_populates="announcements")
    author = relationship("User")
    
    materials = relationship("Material", back_populates="announcement", cascade="all, delete-orphan")
    # Allow queries on an announcement
    queries = relationship("Query", back_populates="announcement", cascade="all, delete-orphan")


class Exam(Base):
    __tablename__ = "exams"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, nullable=False)
    description = Column(Text, nullable=True)
    exam_date = Column(DateTime, nullable=True)
    duration_minutes = Column(Integer, nullable=True)
    points_possible = Column(Integer, default=100)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    classroom_id = Column(Integer, ForeignKey("classrooms.id"))
    author_id = Column(Integer, ForeignKey("users.id"))
    answer_script_path = Column(String, nullable=True)

    classroom = relationship("Classroom", back_populates="exams")
    author = relationship("User")
    results = relationship("ExamResult", back_populates="exam", cascade="all, delete-orphan")
    
    materials = relationship("Material", back_populates="exam", cascade="all, delete-orphan")
    # Allow queries on an exam
    queries = relationship("Query", back_populates="exam", cascade="all, delete-orphan")


class ExamResult(Base):
    __tablename__ = "exam_results"

    id = Column(Integer, primary_key=True, index=True)
    exam_id = Column(Integer, ForeignKey("exams.id"))
    student_id = Column(Integer, ForeignKey("users.id"))
    marks_obtained = Column(Integer, nullable=True)
    feedback = Column(Text, nullable=True)
    graded_by = Column(Integer, ForeignKey("users.id"), nullable=True)
    graded_at = Column(DateTime, nullable=True)

    exam = relationship("Exam", back_populates="results")
    student = relationship("User", foreign_keys=[student_id])
    grader = relationship("User", foreign_keys=[graded_by])

class Material(Base):
    __tablename__ = "materials"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, nullable=False)
    description = Column(Text, nullable=True)
    file_path = Column(String, nullable=True)
    link_url = Column(String, nullable=True)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))

    classroom_id = Column(Integer, ForeignKey("classrooms.id"), nullable=True)

    # Multiple foreign keys to support different parent types:
    related_assignment_id = Column(Integer, ForeignKey("assignments.id"), nullable=True)
    related_announcement_id = Column(Integer, ForeignKey("announcements.id"), nullable=True)
    related_exam_id = Column(Integer, ForeignKey("exams.id"), nullable=True)

    author_id = Column(Integer, ForeignKey("users.id"))
    extracted_text = Column(Text, nullable=True)

    classroom = relationship("Classroom", back_populates="materials")

    assignment = relationship("Assignment", back_populates="materials")
    announcement = relationship("Announcement", back_populates="materials")
    exam = relationship("Exam", back_populates="materials")
    author = relationship("User")


class Query(Base):
    __tablename__ = "queries"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, nullable=False)
    content = Column(Text, nullable=False)
    is_public = Column(Boolean, default=True)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    classroom_id = Column(Integer, ForeignKey("classrooms.id"))
    student_id = Column(Integer, ForeignKey("users.id"))
    
    # Multiple foreign keys to support different parent types:
    related_assignment_id = Column(Integer, ForeignKey("assignments.id"), nullable=True)
    related_announcement_id = Column(Integer, ForeignKey("announcements.id"), nullable=True)
    related_exam_id = Column(Integer, ForeignKey("exams.id"), nullable=True)
    
    # Self-referential foreign key for responses to another query:
    parent_query_id = Column(Integer, ForeignKey("queries.id"), nullable=True)
    
    # Relationships
    classroom = relationship("Classroom", back_populates="queries")
    student = relationship("User")
    
    # Relationships to parent objects (if the Query is attached to one of these)
    assignment = relationship("Assignment", back_populates="queries")
    announcement = relationship("Announcement", back_populates="queries")
    exam = relationship("Exam", back_populates="queries")
    
    # Self-referential relationships for query responses:
    parent_query = relationship("Query", remote_side=[id], back_populates="responses")
    responses = relationship("Query", back_populates="parent_query", cascade="all, delete-orphan")    


backend/models/users.py

from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, Table, Text
from sqlalchemy.orm import relationship
from datetime import datetime, timezone
from classroom_app.database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, nullable=False)
    profile_picture = Column(String, nullable=True)
    bio = Column(Text, nullable=True)
    is_professor = Column(Boolean, default=False)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    last_login = Column(DateTime, nullable=True)
    
    # Relationships
    owned_classes = relationship("Classroom", back_populates="owner")
    enrollments = relationship("Enrollment", back_populates="student")
    sent_notifications = relationship("Notification", foreign_keys="Notification.sender_id", back_populates="sender")
    received_notifications = relationship("Notification", foreign_keys="Notification.recipient_id", back_populates="recipient")

class UserSettings(Base):
    __tablename__ = "user_settings"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), unique=True)
    email_notifications = Column(Boolean, default=True)
    display_theme = Column(String, default="light")
    language_preference = Column(String, default="en")
    
    user = relationship("User")

class LoginHistory(Base):
    __tablename__ = "login_history"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    login_time = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    ip_address = Column(String, nullable=True)
    user_agent = Column(String, nullable=True)
    
    user = relationship("User")



backend/models/tables.py

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Boolean, Text, Enum
from sqlalchemy.orm import relationship
from datetime import datetime, timezone
import enum
from classroom_app.database import Base

class NotificationType(str, enum.Enum):
    INVITE = "invite"
    ANNOUNCEMENT = "announcement"
    ASSIGNMENT = "assignment"
    ASSIGNMENT_GRADED = "assignment_graded"
    ENROLLMENT = "enrollment"
    ENROLLMENT_REQUEST = "enrollment_request"
    ENROLLMENT_ACCEPTED = "enrollment_accepted"
    ENROLLMENT_REJECTED = "enrollment_rejected"
    ENROLLMENT_REMOVED = "enrollment_removed"
    EXAM = "exam"
    EXAM_RESULT = "exam_result"
    QUERY = "query"
    QUERY_RESPONSE = "query_response"
    COMMENT = "comment"

class Notification(Base):
    __tablename__ = "notifications"

    id = Column(Integer, primary_key=True, index=True)
    type = Column(Enum(NotificationType), nullable=False)
    title = Column(String, nullable=False)
    message = Column(Text, nullable=True)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    read = Column(Boolean, default=False)
    action_url = Column(String, nullable=True)
    sender_id = Column(Integer, ForeignKey("users.id"))
    recipient_id = Column(Integer, ForeignKey("users.id"))
    classroom_id = Column(Integer, ForeignKey("classrooms.id"), nullable=True)
    
    # Optional reference IDs for specific notifications
    assignment_id = Column(Integer, ForeignKey("assignments.id"), nullable=True)
    announcement_id = Column(Integer, ForeignKey("announcements.id"), nullable=True)
    exam_id = Column(Integer, ForeignKey("exams.id"), nullable=True)
    query_id = Column(Integer, ForeignKey("queries.id"), nullable=True)

    # Relationships
    sender = relationship("User", foreign_keys=[sender_id], back_populates="sent_notifications")
    recipient = relationship("User", foreign_keys=[recipient_id], back_populates="received_notifications")
    classroom = relationship("Classroom")
    
    
backend/routers/auth.py

from datetime import timedelta, datetime, timezone
from fastapi import APIRouter, Depends, HTTPException, Request, Form, status, Response
from fastapi.responses import RedirectResponse, HTMLResponse
from fastapi.templating import Jinja2Templates
from sqlalchemy.orm import Session
import logging
import os

from classroom_app.config import settings
from classroom_app.database import get_db
from classroom_app.models.users import User
from classroom_app.utils.security import (
    get_password_hash,
    verify_password,
    create_access_token,
    get_current_user_from_cookie,
)
from classroom_app.utils.validators import validate_email, validate_password

logger = logging.getLogger(__name__)
router = APIRouter(tags=["auth"])
templates = Jinja2Templates(directory=os.path.join(os.path.dirname(os.path.dirname(__file__)), "templates"))

@router.get("/login", response_class=HTMLResponse)
async def login_page(request: Request, user = Depends(get_current_user_from_cookie)):
    try:
        if user:
            return RedirectResponse(url="/dashboard", status_code=303)
        return templates.TemplateResponse("login.html", {"request": request, "user": None})
    except Exception as e:
        logger.error(f"Error rendering login page: {str(e)}", exc_info=True)
        return templates.TemplateResponse("login.html", {"request": request, "user": None, "error": "An error occurred"})

@router.post("/login")
async def login(
    request: Request,
    response: Response,
    email: str = Form(...),
    password: str = Form(...),
    remember: bool = Form(False),
    db: Session = Depends(get_db)
):
    try:
        if not email or not password:
            return templates.TemplateResponse(
                "login.html", 
                {"request": request, "error": "Please fill in all fields", "user": None}
            )

        # Normalize email
        email = email.lower().strip()
        
        # Get user and verify password
        user = db.query(User).filter(User.email == email).first()
        if not user:
            logger.warning(f"Login attempt failed: User not found for email {email}")
            return templates.TemplateResponse(
                "login.html", 
                {"request": request, "error": "Incorrect email or password", "user": None}
            )
            
        if not verify_password(password, user.hashed_password):
            logger.warning(f"Login attempt failed: Invalid password for user {email}")
            return templates.TemplateResponse(
                "login.html", 
                {"request": request, "error": "Incorrect email or password", "user": None}
            )

        # Update last login time
        user.last_login = datetime.now(timezone.utc)
        db.commit()

        # Create access token
        access_token_expires = timedelta(
            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 7 if remember else settings.ACCESS_TOKEN_EXPIRE_MINUTES
        )
        access_token = create_access_token(
            data={"sub": str(user.id)}, 
            expires_delta=access_token_expires
        )

        # Create response with cookie
        response = RedirectResponse(url="/dashboard", status_code=303)
        response.set_cookie(
            key="access_token",
            value=access_token,
            httponly=True,
            max_age=60*60*24*7 if remember else settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,
            path="/",
            secure=settings.COOKIE_SECURE,
            domain=settings.COOKIE_DOMAIN,
            samesite=settings.COOKIE_SAMESITE
        )

        logger.info(f"User {user.email} logged in successfully")
        return response

    except Exception as e:
        logger.error(f"Login error: {str(e)}", exc_info=True)
        return templates.TemplateResponse(
            "login.html", 
            {
                "request": request, 
                "error": "An unexpected error occurred. Please try again later.", 
                "user": None
            }
        )

@router.get("/signup", response_class=HTMLResponse)
async def signup_page(request: Request, user = Depends(get_current_user_from_cookie)):
    try:
        if user:
            return RedirectResponse(url="/dashboard", status_code=303)
        return templates.TemplateResponse("signup.html", {"request": request, "user": None})
    except Exception as e:
        logger.error(f"Error rendering signup page: {str(e)}", exc_info=True)
        return templates.TemplateResponse("signup.html", {"request": request, "user": None, "error": "An error occurred"})

@router.post("/signup")
async def signup(
    request: Request,
    full_name: str = Form(...),
    email: str = Form(...),
    password: str = Form(...),
    confirm_password: str = Form(...),
    is_professor: bool = Form(False),
    db: Session = Depends(get_db)
):
    try:
        # Validate required fields
        if not all([full_name, email, password, confirm_password]):
            return templates.TemplateResponse(
                "signup.html", 
                {"request": request, "error": "Please fill in all fields", "user": None}
            )

        # Normalize input
        email = email.lower().strip()
        full_name = full_name.strip()

        # Validate email format
        if not validate_email(email):
            return templates.TemplateResponse(
                "signup.html", 
                {"request": request, "error": "Invalid email format", "user": None}
            )

        # Check password match
        if password != confirm_password:
            return templates.TemplateResponse(
                "signup.html", 
                {"request": request, "error": "Passwords do not match", "user": None}
            )

        # Validate password strength
        is_valid, error_msg = validate_password(password)
        if not is_valid:
            return templates.TemplateResponse(
                "signup.html", 
                {"request": request, "error": error_msg, "user": None}
            )

        # Check if email already exists
        if db.query(User).filter(User.email == email).first():
            return templates.TemplateResponse(
                "signup.html", 
                {"request": request, "error": "Email already registered", "user": None}
            )

        # Create new user
        try:
            hashed_password = get_password_hash(password)
            user = User(
                email=email,
                hashed_password=hashed_password,
                full_name=full_name,
                is_professor=is_professor
            )
            db.add(user)
            db.commit()
            db.refresh(user)
        except Exception as e:
            logger.error(f"Database error during user creation: {str(e)}", exc_info=True)
            db.rollback()
            return templates.TemplateResponse(
                "signup.html",
                {
                    "request": request,
                    "error": "An error occurred while creating your account. Please try again.",
                    "user": None
                }
            )

        # Create access token and login user
        access_token = create_access_token(
            data={"sub": str(user.id)},
            expires_delta=timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        )
        
        response = RedirectResponse(url="/dashboard", status_code=303)
        response.set_cookie(
            key="access_token",
            value=access_token,
            httponly=True,
            max_age=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,
            path="/",
            secure=settings.COOKIE_SECURE,
            domain=settings.COOKIE_DOMAIN,
            samesite=settings.COOKIE_SAMESITE
        )

        logger.info(f"New user registered successfully: {user.email}")
        return response

    except Exception as e:
        logger.error(f"Signup error: {str(e)}", exc_info=True)
        return templates.TemplateResponse(
            "signup.html",
            {
                "request": request,
                "error": "An unexpected error occurred. Please try again later.",
                "user": None
            }
        )

@router.get("/logout")
async def logout(request: Request):
    try:
        logger.info("Processing logout request")
        response = RedirectResponse(url="/login", status_code=303)
        response.delete_cookie(key="access_token", path="/", secure=False, httponly=True)
        logger.info("Successfully logged out user")
        return response
    except Exception as e:
        logger.error(f"Error during logout: {str(e)}", exc_info=True)
        return RedirectResponse(url="/login", status_code=303)



backend/routers/classes.py

from fastapi import APIRouter, Depends, HTTPException, status, Request, Form
from fastapi.templating import Jinja2Templates
from fastapi.responses import RedirectResponse
from sqlalchemy.orm import Session
from typing import Optional
from datetime import datetime, timezone
from pydantic import BaseModel
import os
import shortuuid
import logging

from classroom_app.database import get_db
from classroom_app.models.classes import Classroom, Enrollment, Assignment, Submission, Announcement
from classroom_app.models.users import User
from classroom_app.utils.security import get_current_user_required

def parse_datetime(dt_str: str) -> datetime:
    """Parse datetime string to datetime object with UTC timezone."""
    try:
        dt = datetime.fromisoformat(dt_str.replace('Z', '+00:00'))
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        return dt
    except (ValueError, TypeError) as e:
        raise ValueError(f"Invalid datetime format: {dt_str}") from e

logger = logging.getLogger(__name__)
router = APIRouter(tags=["classes"])
templates = Jinja2Templates(directory=os.path.join(os.path.dirname(os.path.dirname(__file__)), "templates"))

class EnrollmentCreate(BaseModel):
    role: str = "student"  # "student" or "ta"

class AssignmentCreate(BaseModel):
    title: str
    description: Optional[str] = None
    due_date: Optional[datetime] = None
    max_marks: Optional[int] = None

class SubmissionCreate(BaseModel):
    content: str

class GradeSubmission(BaseModel):
    grade: int
    feedback: Optional[str] = None

class AnnouncementCreate(BaseModel):
    title: str
    content: str

@router.get("/dashboard")
async def dashboard(
    request: Request,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    if current_user.is_professor:
        # Professors see only teaching courses (classes they own)
        teaching_courses = db.query(Classroom).filter(Classroom.owner_id == current_user.id).all()
        enrolled_courses = []
    else:
        # Non-professors: fetch enrolled courses as a student
        enrolled_courses = db.query(Enrollment).filter(
            Enrollment.student_id == current_user.id,
            Enrollment.status == "accepted",
            Enrollment.role == "student"
        ).all()
        # Also, if the user is a TA, fetch those classes
        ta_enrollments = db.query(Enrollment).filter(
            Enrollment.student_id == current_user.id,
            Enrollment.status == "accepted",
            Enrollment.role == "ta"
        ).all()
        teaching_courses = [enrollment.classroom for enrollment in ta_enrollments]

    return templates.TemplateResponse("dashboard.html", {
        "request": request,
        "user": current_user,
        "enrolled_courses": enrolled_courses,
        "teaching_courses": teaching_courses
    })


@router.get("/classes/create")
async def create_class_page(
    request: Request,
    current_user: User = Depends(get_current_user_required)
):
    try:
        if not current_user.is_professor:
            return RedirectResponse(url="/dashboard", status_code=303)
        return templates.TemplateResponse("create_class.html", {"request": request, "user": current_user})
    except Exception as e:
        logger.error(f"Error loading create class page: {str(e)}", exc_info=True)
        return templates.TemplateResponse("create_class.html", {
            "request": request,
            "user": current_user,
            "error": "An error occurred while loading the page"
        })

@router.post("/classes/create")
async def create_class(
    request: Request,
    name: str = Form(...),
    subject: str = Form(...),
    description: Optional[str] = Form(None),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    try:
        if not current_user.is_professor:
            raise HTTPException(status_code=403, detail="Only professors can create classes")

        new_class = Classroom(
            name=name,
            subject=subject,
            description=description,
            class_code=shortuuid.ShortUUID().random(length=6).upper(),
            owner_id=current_user.id,
            created_at=datetime.now(timezone.utc)
        )
        db.add(new_class)
        db.commit()
        db.refresh(new_class)
        
        logger.info(f"Class created: {new_class.name} by {current_user.email}")
        return RedirectResponse(url="/dashboard", status_code=303)
    except Exception as e:
        logger.error(f"Error creating class: {str(e)}", exc_info=True)
        return templates.TemplateResponse("create_class.html", {
            "request": request,
            "user": current_user,
            "error": "An error occurred while creating the class"
        })

@router.get("/classes/join-class")
async def join_class_page(
    request: Request,
    current_user: User = Depends(get_current_user_required)
):
    try:
        if current_user.is_professor:
            return RedirectResponse(url="/dashboard", status_code=303)
        return templates.TemplateResponse("join_class.html", {"request": request, "user": current_user})
    except Exception as e:
        logger.error(f"Error loading join class page: {str(e)}", exc_info=True)
        return templates.TemplateResponse("join_class.html", {
            "request": request,
            "user": current_user,
            "error": "An error occurred while loading the page"
        })

@router.post("/classes/join-class")
async def join_class(
    request: Request,
    class_code: str = Form(...),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    try:
        classroom = db.query(Classroom).filter(Classroom.class_code == class_code.upper()).first()
        if not classroom:
            return templates.TemplateResponse("join_class.html", {"request": request, "user": current_user, "error": "Invalid class code"})

        existing_enrollment = db.query(Enrollment).filter(
            Enrollment.classroom_id == classroom.id,
            Enrollment.student_id == current_user.id
        ).first()

        if existing_enrollment:
            return templates.TemplateResponse("join_class.html", {"request": request, "user": current_user, "error": "You are already enrolled in this class"})

        enrollment = Enrollment(
            classroom_id=classroom.id,
            student_id=current_user.id,
            role="student",
            status="accepted",
            enrolled_at=datetime.now(timezone.utc)
        )
        db.add(enrollment)
        db.commit()

        logger.info(f"User {current_user.email} joined class {classroom.name}")
        return RedirectResponse(url="/dashboard", status_code=303)
    except Exception as e:
        logger.error(f"Error joining class: {str(e)}", exc_info=True)
        return templates.TemplateResponse("join_class.html", {"request": request, "user": current_user, "error": "An error occurred while joining the class"})

@router.post("/classes/{class_id}/join")
async def join_class(
    class_id: int,
    enrollment: EnrollmentCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    classroom = db.query(Classroom).filter(Classroom.id == class_id).first()
    if not classroom:
        raise HTTPException(status_code=404, detail="Class not found")

    existing_enrollment = db.query(Enrollment).filter(
        Enrollment.classroom_id == class_id,
        Enrollment.student_id == current_user.id
    ).first()
    
    if existing_enrollment:
        raise HTTPException(status_code=400, detail="Already enrolled in this class")

    if enrollment.role == "ta" and not current_user.is_professor:
        owner_permission = classroom.owner_id == current_user.id
        if not owner_permission:
            raise HTTPException(status_code=403, detail="Only professors can directly become TAs")

    new_enrollment = Enrollment(
        student_id=current_user.id,
        classroom_id=class_id,
        role=enrollment.role,
        status="accepted" if enrollment.role == "ta" else "pending"
    )
    db.add(new_enrollment)
    db.commit()
    db.refresh(new_enrollment)
    return RedirectResponse(url="/dashboard", status_code=status.HTTP_303_SEE_OTHER)

@router.post("/classes/{class_id}/assignments")
async def create_assignment(
    class_id: int,
    assignment: AssignmentCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    try:
        logger.debug(f"Received assignment data: {assignment.dict()}")
        
        enrollment = db.query(Enrollment).filter(
            Enrollment.classroom_id == class_id,
            Enrollment.student_id == current_user.id,
            Enrollment.status == "accepted"
        ).first()

        if not enrollment or (enrollment.role != "ta" and not current_user.is_professor):
            raise HTTPException(status_code=403, detail="Only professors and TAs can create assignments")

        parsed_due_date = None
        if assignment.due_date:
            try:
                parsed_due_date = parse_datetime(assignment.due_date)
            except ValueError:
                raise HTTPException(status_code=400, detail="Invalid due date format")

        new_assignment = Assignment(
            title=assignment.title,
            description=assignment.description,
            due_date=parsed_due_date,
            max_marks=assignment.max_marks,
            classroom_id=class_id,
            created_by_id=current_user.id
        )
        db.add(new_assignment)
        db.commit()
        db.refresh(new_assignment)
        return new_assignment
    except Exception as e:
        logger.error(f"Error creating assignment: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="An error occurred while creating the assignment")

@router.post("/assignments/{assignment_id}/submissions")
async def submit_assignment(
    assignment_id: int,
    submission: SubmissionCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    try:
        assignment = db.query(Assignment).filter(Assignment.id == assignment_id).first()
        if not assignment:
            raise HTTPException(status_code=404, detail="Assignment not found")

        enrollment = db.query(Enrollment).filter(
            Enrollment.classroom_id == assignment.classroom_id,
            Enrollment.student_id == current_user.id,
            Enrollment.status == "accepted",
            Enrollment.role == "student"
        ).first()
        if not enrollment:
            raise HTTPException(status_code=403, detail="Only enrolled students can submit assignments")

        new_submission = Submission(
            content=submission.content,
            assignment_id=assignment_id,
            student_id=current_user.id
        )
        db.add(new_submission)
        db.commit()
        db.refresh(new_submission)
        return new_submission
    except Exception as e:
        logger.error(f"Error submitting assignment: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="An error occurred while submitting the assignment")

@router.post("/submissions/{submission_id}/grade")
async def grade_submission(
    submission_id: int,
    grade_data: GradeSubmission,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    try:
        submission = db.query(Submission).filter(Submission.id == submission_id).first()
        if not submission:
            raise HTTPException(status_code=404, detail="Submission not found")

        assignment = db.query(Assignment).filter(Assignment.id == submission.assignment_id).first()
        enrollment = db.query(Enrollment).filter(
            Enrollment.classroom_id == assignment.classroom_id,
            Enrollment.student_id == current_user.id,
            Enrollment.status == "accepted"
        ).first()

        if not enrollment or (enrollment.role != "ta" and not current_user.is_professor):
            raise HTTPException(status_code=403, detail="Only professors and TAs can grade submissions")

        if assignment.max_marks and grade_data.grade > assignment.max_marks:
            raise HTTPException(status_code=400, detail=f"Grade cannot exceed maximum marks: {assignment.max_marks}")

        submission.grade = grade_data.grade
        submission.feedback = grade_data.feedback
        submission.graded_by_id = current_user.id
        submission.graded_at = datetime.now(timezone.utc)
        
        db.commit()
        db.refresh(submission)
        return submission
    except Exception as e:
        logger.error(f"Error grading submission: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="An error occurred while grading the submission")

@router.post("/classes/{class_id}/announcements")
async def create_announcement(
    class_id: int,
    announcement: AnnouncementCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    try:
        logger.debug(f"Starting announcement creation with data: {announcement.dict()}")
        logger.debug(f"Class ID: {class_id}, User ID: {current_user.id}")
        
        # Check if the classroom exists
        classroom = db.query(Classroom).filter(Classroom.id == class_id).first()
        if not classroom:
            raise HTTPException(status_code=404, detail="Classroom not found")
        
        # Check enrollment and permissions
        enrollment = db.query(Enrollment).filter(
            Enrollment.classroom_id == class_id,
            Enrollment.student_id == current_user.id,
            Enrollment.status == EnrollmentStatus.ACCEPTED
        ).first()
        
        logger.debug(f"Found enrollment: {enrollment}")
        if not enrollment:
            logger.warning(f"No enrollment found for user {current_user.id} in class {class_id}")
            raise HTTPException(status_code=403, detail="You are not enrolled in this class")
            
        if enrollment.role != Role.TA and not current_user.is_professor:
            logger.warning(f"User {current_user.id} with role {enrollment.role} attempted to create announcement")
            raise HTTPException(status_code=403, detail="Only professors and TAs can create announcements")

        # Create the announcement
        new_announcement = Announcement(
            title=announcement.title,
            content=announcement.content,
            classroom_id=class_id,
            author_id=current_user.id
        )
        logger.debug(f"Created announcement object: {new_announcement.__dict__}")
        
        db.add(new_announcement)
        db.commit()
        db.refresh(new_announcement)
        logger.info(f"Successfully created announcement with ID: {new_announcement.id}")
        return new_announcement
    except HTTPException as he:
        # Re-raise HTTP exceptions as they are already properly formatted
        raise he
    except Exception as e:
        logger.error(f"Error creating announcement: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="An error occurred while creating the announcement")

@router.get("/classes/{class_id}")
async def view_class(
    class_id: int,
    request: Request,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    try:
        classroom = db.query(Classroom).filter(Classroom.id == class_id).first()
        if not classroom:
            raise HTTPException(status_code=404, detail="Class not found")

        enrollment = db.query(Enrollment).filter(
            Enrollment.classroom_id == class_id,
            Enrollment.student_id == current_user.id,
            Enrollment.status == "accepted"
        ).first()

        is_owner = classroom.owner_id == current_user.id
        if not enrollment and not is_owner:
            raise HTTPException(status_code=403, detail="Access denied")

        announcements = db.query(Announcement).filter(Announcement.classroom_id == class_id).order_by(Announcement.created_at.desc()).all()
        assignments = db.query(Assignment).filter(Assignment.classroom_id == class_id).order_by(Assignment.created_at.desc()).all()
        ta_enrollments = db.query(Enrollment).filter(
            Enrollment.classroom_id == class_id,
            Enrollment.status == "accepted",
            Enrollment.role == "ta"
        ).all()
        student_enrollments = db.query(Enrollment).filter(
            Enrollment.classroom_id == class_id,
            Enrollment.status == "accepted",
            Enrollment.role == "student"
        ).all()

        def get_submission(student_id: int, assignment_id: int):
            return db.query(Submission).filter(
                Submission.student_id == student_id,
                Submission.assignment_id == assignment_id
            ).first()

        is_teacher = is_owner or (enrollment and enrollment.role == "ta")
        return templates.TemplateResponse("class.html", {
            "request": request,
            "user": current_user,
            "classroom": classroom,
            "is_teacher": is_teacher,
            "announcements": announcements,
            "assignments": assignments,
            "ta_enrollments": ta_enrollments,
            "student_enrollments": student_enrollments,
            "get_submission": get_submission
        })
    except Exception as e:
        logger.error(f"Error loading class page: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="An error occurred while loading the class page")


backend/routers/enrollments.py

from fastapi import APIRouter, Request, Depends, Form, HTTPException, status
from fastapi.responses import RedirectResponse
from fastapi.templating import Jinja2Templates
from sqlalchemy.orm import Session
from classroom_app.database import get_db
from classroom_app.models.classes import Classroom, Enrollment
from classroom_app.models.users import User
from classroom_app.models.notifications import Notification, NotificationType
from classroom_app.utils.security import get_current_user_required
import os
from datetime import datetime, timezone

router = APIRouter(tags=["enrollments"])
templates = Jinja2Templates(directory=os.path.join("classroom_app", "templates"))

@router.get("/classes/join-class")
async def join_class_page(
    request: Request,
    current_user: User = Depends(get_current_user_required)
):
    if current_user.is_professor:
        return RedirectResponse(url="/dashboard", status_code=303)
    return templates.TemplateResponse("join_class.html", {"request": request, "user": current_user})

@router.post("/classes/join-class")
async def join_class(
    request: Request,
    class_code: str = Form(...),
    role: str = Form("student"),  # "student" or "ta"
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    if current_user.is_professor:
        raise HTTPException(status_code=403, detail="Professors cannot join classes")
    
    classroom = db.query(Classroom).filter(Classroom.class_code == class_code.strip().upper()).first()
    if not classroom:
        return templates.TemplateResponse("join_class.html", {"request": request, "user": current_user, "error": "Invalid class code"})
    
    existing_enrollment = db.query(Enrollment).filter(
        Enrollment.student_id == current_user.id,
        Enrollment.classroom_id == classroom.id
    ).first()
    
    if existing_enrollment:
        if existing_enrollment.status == "accepted":
            return RedirectResponse(url=f"/classes/{classroom.id}", status_code=303)
        elif existing_enrollment.status == "pending":
            return templates.TemplateResponse("join_class.html", {"request": request, "user": current_user, "message": "Request already pending"})
        else:
            existing_enrollment.status = "pending"
            db.commit()
    else:
        new_enrollment = Enrollment(
            student_id=current_user.id,
            classroom_id=classroom.id,
            status="pending"
        )
        db.add(new_enrollment)
        db.commit()
    
    notification = Notification(
        type=NotificationType.ENROLLMENT_REQUEST,
        title="New Enrollment Request",
        message=f"{current_user.full_name} wants to join your {classroom.name} class",
        sender_id=current_user.id,
        recipient_id=classroom.owner_id,
        classroom_id=classroom.id,
        action_url=f"/enrollments/manage/{classroom.id}",
        created_at=datetime.now(timezone.utc)
    )
    db.add(notification)
    db.commit()
    
    return RedirectResponse(url="/dashboard", status_code=303)

@router.get("/enrollments/manage/{class_id}")
async def manage_enrollments(
    class_id: int,
    request: Request,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    classroom = db.query(Classroom).filter(Classroom.id == class_id).first()
    if not classroom or classroom.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    pending_enrollments = db.query(Enrollment).filter(
        Enrollment.classroom_id == class_id,
        Enrollment.status == "pending"
    ).all()
    
    pending_students = []
    for enrollment in pending_enrollments:
        student = db.query(User).get(enrollment.student_id)
        if student:
            pending_students.append({"student": student, "enrollment_id": enrollment.id})
    
    accepted_enrollments = db.query(Enrollment).filter(
        Enrollment.classroom_id == class_id,
        Enrollment.status == "accepted"
    ).all()
    
    enrolled_students = []
    for enrollment in accepted_enrollments:
        student = db.query(User).get(enrollment.student_id)
        if student:
            enrolled_students.append({"student": student, "enrollment_id": enrollment.id})
    
    return templates.TemplateResponse("manage_enrollments.html", {
        "request": request,
        "user": current_user,
        "classroom": classroom,
        "pending_students": pending_students,
        "enrolled_students": enrolled_students
    })

@router.post("/enrollments/{enrollment_id}/accept")
async def accept_enrollment(
    enrollment_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    enrollment = db.query(Enrollment).filter(Enrollment.id == enrollment_id).first()
    if not enrollment:
        raise HTTPException(status_code=404, detail="Enrollment not found")
    
    classroom = db.query(Classroom).filter(Classroom.id == enrollment.classroom_id).first()
    if not classroom or classroom.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    enrollment.status = "accepted"
    db.commit()
    
    student = db.query(User).get(enrollment.student_id)
    notification = Notification(
        type=NotificationType.ENROLLMENT_ACCEPTED,
        title="Enrollment Accepted",
        message=f"Your request to join {classroom.name} has been accepted",
        sender_id=current_user.id,
        recipient_id=enrollment.student_id,
        classroom_id=classroom.id,
        action_url=f"/classes/{classroom.id}",
        created_at=datetime.now(timezone.utc)
    )
    db.add(notification)
    db.commit()
    
    return RedirectResponse(url=f"/enrollments/manage/{classroom.id}", status_code=303)

@router.post("/enrollments/{enrollment_id}/reject")
async def reject_enrollment(
    enrollment_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    enrollment = db.query(Enrollment).filter(Enrollment.id == enrollment_id).first()
    if not enrollment:
        raise HTTPException(status_code=404, detail="Enrollment not found")
    
    classroom = db.query(Classroom).filter(Classroom.id == enrollment.classroom_id).first()
    if not classroom or classroom.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    enrollment.status = "rejected"
    db.commit()
    
    notification = Notification(
        type=NotificationType.ENROLLMENT_REJECTED,
        title="Enrollment Rejected",
        message=f"Your request to join {classroom.name} has been rejected",
        sender_id=current_user.id,
        recipient_id=enrollment.student_id,
        classroom_id=classroom.id,
        created_at=datetime.now(timezone.utc)
    )
    db.add(notification)
    db.commit()
    
    return RedirectResponse(url=f"/enrollments/manage/{classroom.id}", status_code=303)

@router.post("/enrollments/{enrollment_id}/remove")
async def remove_student(
    enrollment_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    enrollment = db.query(Enrollment).filter(Enrollment.id == enrollment_id).first()
    if not enrollment:
        raise HTTPException(status_code=404, detail="Enrollment not found")
    
    classroom = db.query(Classroom).filter(Classroom.id == enrollment.classroom_id).first()
    if not classroom or classroom.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    student_id = enrollment.student_id
    db.delete(enrollment)
    db.commit()
    
    notification = Notification(
        type=NotificationType.ENROLLMENT_REMOVED,
        title="Removed from Class",
        message=f"You have been removed from the class {classroom.name}",
        sender_id=current_user.id,
        recipient_id=student_id,
        classroom_id=classroom.id,
        action_url=f"/classes/{classroom.id}",
        created_at=datetime.now(timezone.utc)
    )
    db.add(notification)
    db.commit()
    
    return RedirectResponse(url=f"/enrollments/manage/{classroom.id}", status_code=303)


backend/routers/notifications.py

from fastapi import APIRouter, Request, Depends, HTTPException, status
from fastapi.responses import RedirectResponse
from fastapi.templating import Jinja2Templates
from sqlalchemy.orm import Session
from datetime import datetime, timezone
import os

from classroom_app.database import get_db
from classroom_app.models.notifications import Notification
from classroom_app.models.classes import Classroom, Enrollment
from classroom_app.models.users import User
from classroom_app.utils.security import get_current_user_required

router = APIRouter(tags=["notifications"])
templates = Jinja2Templates(directory=os.path.join("classroom_app", "templates"))

@router.get("/notifications")
async def get_notifications(
    request: Request,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    notifications = (
        db.query(Notification)
        .filter(Notification.recipient_id == current_user.id)
        .order_by(Notification.created_at.desc())
        .all()
    )
    return templates.TemplateResponse("notifications.html", {"request": request, "user": current_user, "notifications": notifications})

@router.get("/notifications/count")
async def get_unread_count(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    count = db.query(Notification).filter(Notification.recipient_id == current_user.id, Notification.read == False).count()
    return {"count": count}

@router.post("/notifications/{notification_id}/read")
async def mark_as_read(
    notification_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    notification = db.query(Notification).filter(Notification.id == notification_id).first()
    if not notification or notification.recipient_id != current_user.id:
        raise HTTPException(status_code=404, detail="Notification not found")
    
    notification.read = True
    db.commit()
    
    if notification.action_url:
        return RedirectResponse(url=notification.action_url, status_code=303)
    return RedirectResponse(url="/notifications", status_code=303)

@router.post("/notifications/read-all")
async def mark_all_as_read(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    db.query(Notification).filter(Notification.recipient_id == current_user.id, Notification.read == False).update({"read": True})
    db.commit()
    return RedirectResponse(url="/notifications", status_code=303)

@router.post("/invite-student")
async def invite_student(
    class_id: int,
    email: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    classroom = db.query(Classroom).filter(Classroom.id == class_id).first()
    if not classroom or classroom.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    student = db.query(User).filter(User.email == email, User.is_professor == False).first()
    if not student:
        raise HTTPException(status_code=404, detail="Student not found")
    
    existing_enrollment = db.query(Enrollment).filter(
        Enrollment.student_id == student.id,
        Enrollment.classroom_id == classroom.id
    ).first()
    
    if existing_enrollment:
        if existing_enrollment.status == "accepted":
            raise HTTPException(status_code=400, detail="Student already enrolled")
        elif existing_enrollment.status == "pending":
            raise HTTPException(status_code=400, detail="Invitation already pending")
        else:
            existing_enrollment.status = "pending"
            db.commit()
    else:
        new_enrollment = Enrollment(
            student_id=student.id,
            classroom_id=classroom.id,
            status="pending"
        )
        db.add(new_enrollment)
        db.commit()
    
    notification = Notification(
        type="class_invitation",
        title="Class Invitation",
        message=f"{current_user.full_name} has invited you to join {classroom.name}",
        sender_id=current_user.id,
        recipient_id=student.id,
        classroom_id=classroom.id,
        action_url=f"/enrollments/respond/{classroom.id}",
        created_at=datetime.now(timezone.utc)
    )
    db.add(notification)
    db.commit()
    
    return {"status": "success", "message": "Invitation sent"}


backend/routers/announcements.py

from fastapi import APIRouter, Request, Depends, Form, HTTPException
from fastapi.responses import RedirectResponse
from fastapi.templating import Jinja2Templates
from sqlalchemy.orm import Session
import os

from classroom_app.database import get_db
from classroom_app.models.classes import Classroom, Announcement, Enrollment
from classroom_app.models.users import User
from classroom_app.utils.security import get_current_user_required

router = APIRouter(tags=["announcements"])
templates = Jinja2Templates(directory=os.path.join("classroom_app", "templates"))

@router.get("/classes/{class_id}/announcements")
async def view_announcements(
    class_id: int,
    request: Request,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    classroom = db.query(Classroom).filter(Classroom.id == class_id).first()
    if not classroom:
        raise HTTPException(status_code=404, detail="Class not found")
    announcements = db.query(Announcement).filter(
        Announcement.classroom_id == class_id
    ).order_by(Announcement.created_at.desc()).all()
    return templates.TemplateResponse(
        "announcements.html",
        {"request": request, "user": current_user, "classroom": classroom, "announcements": announcements}
    )

@router.post("/classes/{class_id}/announcements")
async def post_announcement(
    class_id: int,
    request: Request,
    content: str = Form(...),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_required)
):
    classroom = db.query(Classroom).filter(Classroom.id == class_id).first()
    if not classroom:
        raise HTTPException(status_code=404, detail="Class not found")
    # Only professor (owner) or TA can post announcements.
    is_ta = db.query(Enrollment).filter(
        Enrollment.classroom_id == class_id,
        Enrollment.student_id == current_user.id,
        Enrollment.status == "accepted",
        Enrollment.role == "ta"
    ).first()
    if classroom.owner_id != current_user.id and not is_ta:
        raise HTTPException(status_code=403, detail="Not authorized to post announcements")
    
    announcement = Announcement(
        content=content,
        classroom_id=class_id,
        author_id=current_user.id
    )
    db.add(announcement)
    db.commit()
    return RedirectResponse(url=f"/classes/{class_id}/announcements", status_code=303)


